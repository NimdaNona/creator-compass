import { BasePlatformService } from './base-platform-service';
import type {
  PlatformConnection,
  PlatformContent,
  PlatformAnalytics,
  PlatformLimits,
  ValidationResult,
  ContentType,
  ListOptions
} from '@/types/platform-integrations';

export class YouTubeService extends BasePlatformService {
  protected platform = 'youtube' as const;
  protected authConfig = {
    clientId: process.env.YOUTUBE_CLIENT_ID || '',
    clientSecret: process.env.YOUTUBE_CLIENT_SECRET || '',
    redirectUri: process.env.YOUTUBE_REDIRECT_URI || 'https://creatorsaicompass.com/api/auth/youtube/callback',
    scopes: [
      'https://www.googleapis.com/auth/youtube',
      'https://www.googleapis.com/auth/youtube.upload',
      'https://www.googleapis.com/auth/youtube.readonly',
      'https://www.googleapis.com/auth/yt-analytics.readonly',
      'https://www.googleapis.com/auth/userinfo.profile'
    ],
    authUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
    tokenUrl: 'https://oauth2.googleapis.com/token'
  };

  async connect(authCode: string): Promise<PlatformConnection> {
    // Exchange code for tokens
    const tokens = await this.exchangeCodeForTokens(authCode);
    
    // Get user profile
    const profile = await this.getUserProfile(tokens.accessToken);
    
    // Create connection
    const connection: PlatformConnection = {
      id: '', // Will be generated by Prisma
      userId: '', // Will be set by the calling code
      platform: 'youtube',
      accountId: profile.id,
      accountName: profile.snippet.title,
      accountImage: profile.snippet.thumbnails.default.url,
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      tokenExpiry: tokens.expiresIn ? new Date(Date.now() + tokens.expiresIn * 1000) : undefined,
      scopes: this.authConfig.scopes,
      isActive: true,
      metadata: {
        channelId: profile.id,
        subscriberCount: profile.statistics.subscriberCount,
        videoCount: profile.statistics.videoCount
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return await this.saveConnection(connection);
  }

  async refreshToken(connection: PlatformConnection): Promise<PlatformConnection> {
    if (!connection.refreshToken) {
      throw new Error('No refresh token available');
    }

    const tokens = await this.refreshAccessToken(connection.refreshToken);
    
    connection.accessToken = tokens.accessToken;
    if (tokens.refreshToken) {
      connection.refreshToken = tokens.refreshToken;
    }
    if (tokens.expiresIn) {
      connection.tokenExpiry = new Date(Date.now() + tokens.expiresIn * 1000);
    }
    
    return await this.saveConnection(connection);
  }

  async publishContent(connectionId: string, content: Partial<PlatformContent>): Promise<PlatformContent> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    // Validate content
    const validation = this.validateContent(content);
    if (!validation.valid) {
      throw new Error(`Invalid content: ${validation.errors?.map(e => e.message).join(', ')}`);
    }

    // Upload video if needed
    let videoId: string;
    if (content.type === 'video' && content.metadata?.videoFile) {
      videoId = await this.uploadVideo(connection, content);
    } else {
      throw new Error('YouTube requires video content');
    }

    // Update video metadata
    await this.updateVideoMetadata(connection, videoId, content);

    // Create thumbnail if provided
    if (content.thumbnail) {
      await this.uploadThumbnail(connection, videoId, content.thumbnail);
    }

    // Return created content
    const publishedContent: PlatformContent = {
      id: videoId,
      platformId: videoId,
      platform: 'youtube',
      title: content.title!,
      description: content.description,
      type: content.type as ContentType,
      status: 'published',
      publishedAt: new Date(),
      url: `https://youtube.com/watch?v=${videoId}`,
      thumbnail: content.thumbnail,
      tags: content.tags,
      metadata: {
        ...content.metadata,
        videoId
      }
    };

    return publishedContent;
  }

  async getAnalytics(connectionId: string, period: { start: Date; end: Date }): Promise<PlatformAnalytics> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    // Get channel analytics
    const analytics = await this.getChannelAnalytics(connection, period);
    
    // Get top videos
    const topVideos = await this.getTopVideos(connection, period);
    
    // Get audience data
    const audienceData = await this.getAudienceData(connection);

    return {
      platform: 'youtube',
      connectionId,
      period,
      metrics: {
        followers: analytics.subscriberCount,
        followersGrowth: analytics.subscriberChange,
        totalViews: analytics.views,
        totalEngagement: analytics.likes + analytics.comments + analytics.shares,
        avgEngagementRate: analytics.engagementRate,
        totalContent: analytics.videoCount,
        topContent: topVideos
      },
      audienceData
    };
  }

  async listContent(connectionId: string, options?: ListOptions): Promise<PlatformContent[]> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    const response = await fetch(
      `https://www.googleapis.com/youtube/v3/search?` +
      `part=snippet&channelId=${connection.metadata?.channelId}&type=video&` +
      `maxResults=${options?.limit || 50}&order=${options?.sortBy === 'date' ? 'date' : 'viewCount'}`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch videos');
    }

    const data = await response.json();
    
    // Get detailed stats for each video
    const videoIds = data.items.map((item: any) => item.id.videoId).join(',');
    const statsResponse = await fetch(
      `https://www.googleapis.com/youtube/v3/videos?part=statistics,contentDetails&id=${videoIds}`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    const statsData = await statsResponse.json();
    const statsMap = new Map(statsData.items.map((item: any) => [item.id, item]));

    return data.items.map((item: any) => {
      const stats = statsMap.get(item.id.videoId);
      return {
        id: item.id.videoId,
        platformId: item.id.videoId,
        platform: 'youtube',
        title: item.snippet.title,
        description: item.snippet.description,
        type: 'video' as ContentType,
        status: 'published',
        publishedAt: new Date(item.snippet.publishedAt),
        url: `https://youtube.com/watch?v=${item.id.videoId}`,
        thumbnail: item.snippet.thumbnails.high.url,
        metrics: stats ? {
          views: parseInt(stats.statistics.viewCount),
          likes: parseInt(stats.statistics.likeCount || '0'),
          comments: parseInt(stats.statistics.commentCount || '0'),
          shares: 0, // YouTube doesn't provide share count via API
          watchTime: this.parseDuration(stats.contentDetails.duration)
        } : undefined,
        tags: item.snippet.tags || []
      };
    });
  }

  getPlatformLimits(): PlatformLimits {
    return {
      platform: 'youtube',
      content: {
        titleMaxLength: 100,
        descriptionMaxLength: 5000,
        tagsMax: 500, // Total character count for all tags
        videoMaxDuration: 12 * 60 * 60, // 12 hours in seconds
        videoMaxSize: 256 * 1024 * 1024 * 1024, // 256GB
        supportedFormats: ['mp4', 'mov', 'avi', 'wmv', 'flv', 'mkv', 'webm']
      },
      posting: {
        // YouTube doesn't have strict posting limits
      }
    };
  }

  validateContent(content: Partial<PlatformContent>): ValidationResult {
    const errors: any[] = [];
    const warnings: any[] = [];
    const limits = this.getPlatformLimits();

    // Required fields
    if (!content.title) {
      errors.push({ field: 'title', message: 'Title is required', code: 'REQUIRED_FIELD' });
    } else if (content.title.length > limits.content.titleMaxLength!) {
      errors.push({ 
        field: 'title', 
        message: `Title must be ${limits.content.titleMaxLength} characters or less`, 
        code: 'MAX_LENGTH' 
      });
    }

    // Description validation
    if (content.description && content.description.length > limits.content.descriptionMaxLength!) {
      errors.push({ 
        field: 'description', 
        message: `Description must be ${limits.content.descriptionMaxLength} characters or less`, 
        code: 'MAX_LENGTH' 
      });
    }

    // Video file validation
    if (content.type === 'video' && !content.metadata?.videoFile) {
      errors.push({ field: 'video', message: 'Video file is required', code: 'REQUIRED_FIELD' });
    }

    // Tags validation
    if (content.tags) {
      const totalTagLength = content.tags.join('').length;
      if (totalTagLength > limits.content.tagsMax!) {
        warnings.push({
          field: 'tags',
          message: `Total tag characters (${totalTagLength}) exceeds recommended limit (${limits.content.tagsMax})`,
          suggestion: 'Consider using fewer or shorter tags'
        });
      }
    }

    // SEO recommendations
    if (content.title && content.title.length < 60) {
      warnings.push({
        field: 'title',
        message: 'Title could be longer for better SEO (60-70 characters recommended)',
        suggestion: 'Add more descriptive keywords to your title'
      });
    }

    if (!content.tags || content.tags.length < 5) {
      warnings.push({
        field: 'tags',
        message: 'Consider adding more tags for better discoverability',
        suggestion: 'Add 10-15 relevant tags'
      });
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  protected async testConnection(connection: PlatformConnection): Promise<boolean> {
    try {
      const response = await fetch(
        'https://www.googleapis.com/youtube/v3/channels?part=id&mine=true',
        {
          headers: {
            'Authorization': `Bearer ${connection.accessToken}`
          }
        }
      );

      return response.ok;
    } catch {
      return false;
    }
  }

  // Private helper methods
  private async getUserProfile(accessToken: string): Promise<any> {
    const response = await fetch(
      'https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&mine=true',
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch user profile');
    }

    const data = await response.json();
    return data.items[0];
  }

  private async uploadVideo(connection: PlatformConnection, content: Partial<PlatformContent>): Promise<string> {
    // This would implement the YouTube resumable upload protocol
    // For now, returning a placeholder
    return 'video-id-placeholder';
  }

  private async updateVideoMetadata(connection: PlatformConnection, videoId: string, content: Partial<PlatformContent>): Promise<void> {
    const response = await fetch(
      `https://www.googleapis.com/youtube/v3/videos?part=snippet,status`,
      {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          id: videoId,
          snippet: {
            title: content.title,
            description: content.description,
            tags: content.tags,
            categoryId: content.metadata?.categoryId || '22' // Default to People & Blogs
          },
          status: {
            privacyStatus: content.metadata?.privacy || 'public'
          }
        })
      }
    );

    if (!response.ok) {
      throw new Error('Failed to update video metadata');
    }
  }

  private async uploadThumbnail(connection: PlatformConnection, videoId: string, thumbnailUrl: string): Promise<void> {
    // This would download the thumbnail and upload it to YouTube
    // Requires implementation of thumbnail upload API
  }

  private async getChannelAnalytics(connection: PlatformConnection, period: { start: Date; end: Date }): Promise<any> {
    const response = await fetch(
      `https://youtubeanalytics.googleapis.com/v2/reports?` +
      `ids=channel==${connection.metadata?.channelId}&` +
      `startDate=${period.start.toISOString().split('T')[0]}&` +
      `endDate=${period.end.toISOString().split('T')[0]}&` +
      `metrics=views,likes,comments,shares,subscribersGained,subscribersLost&` +
      `dimensions=day`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch analytics');
    }

    const data = await response.json();
    
    // Calculate totals and changes
    const totals = data.rows.reduce((acc: any, row: any) => ({
      views: acc.views + row[1],
      likes: acc.likes + row[2],
      comments: acc.comments + row[3],
      shares: acc.shares + row[4],
      subscribersGained: acc.subscribersGained + row[5],
      subscribersLost: acc.subscribersLost + row[6]
    }), { views: 0, likes: 0, comments: 0, shares: 0, subscribersGained: 0, subscribersLost: 0 });

    // Get current subscriber count
    const channelResponse = await fetch(
      `https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${connection.metadata?.channelId}`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    const channelData = await channelResponse.json();
    const currentStats = channelData.items[0].statistics;

    return {
      views: totals.views,
      likes: totals.likes,
      comments: totals.comments,
      shares: totals.shares,
      subscriberCount: parseInt(currentStats.subscriberCount),
      subscriberChange: totals.subscribersGained - totals.subscribersLost,
      videoCount: parseInt(currentStats.videoCount),
      engagementRate: ((totals.likes + totals.comments + totals.shares) / totals.views) * 100
    };
  }

  private async getTopVideos(connection: PlatformConnection, period: { start: Date; end: Date }): Promise<PlatformContent[]> {
    const videos = await this.listContent(connection.id, {
      limit: 10,
      sortBy: 'views',
      startDate: period.start,
      endDate: period.end
    });

    return videos;
  }

  private async getAudienceData(connection: PlatformConnection): Promise<any> {
    // Fetch demographic data from YouTube Analytics API
    const response = await fetch(
      `https://youtubeanalytics.googleapis.com/v2/reports?` +
      `ids=channel==${connection.metadata?.channelId}&` +
      `startDate=${new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}&` +
      `endDate=${new Date().toISOString().split('T')[0]}&` +
      `metrics=viewerPercentage&` +
      `dimensions=ageGroup,gender`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      return null;
    }

    const data = await response.json();
    
    // Process demographic data
    const demographics: any = {
      age: {},
      gender: {}
    };

    data.rows.forEach((row: any) => {
      const [ageGroup, gender, percentage] = row;
      demographics.age[ageGroup] = (demographics.age[ageGroup] || 0) + percentage;
      demographics.gender[gender] = (demographics.gender[gender] || 0) + percentage;
    });

    return {
      demographics,
      topLocations: [], // Would need another API call for geographic data
      activeHours: [] // Would need hourly analytics data
    };
  }

  private parseDuration(duration: string): number {
    // Parse ISO 8601 duration to seconds
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;
    
    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');
    
    return hours * 3600 + minutes * 60 + seconds;
  }
}