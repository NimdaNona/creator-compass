import { BasePlatformService } from './base-platform-service';
import type {
  PlatformConnection,
  PlatformContent,
  PlatformAnalytics,
  PlatformLimits,
  ValidationResult,
  ContentType,
  ListOptions
} from '@/types/platform-integrations';

export class TwitterService extends BasePlatformService {
  protected platform = 'twitter' as const;
  protected authConfig = {
    clientId: process.env.TWITTER_CLIENT_ID || '',
    clientSecret: process.env.TWITTER_CLIENT_SECRET || '',
    redirectUri: process.env.TWITTER_REDIRECT_URI || 'https://creatorsaicompass.com/api/auth/twitter/callback',
    scopes: [
      'tweet.read',
      'tweet.write',
      'users.read',
      'follows.read',
      'follows.write',
      'offline.access'
    ],
    authUrl: 'https://twitter.com/i/oauth2/authorize',
    tokenUrl: 'https://api.twitter.com/2/oauth2/token'
  };

  private apiBaseUrl = 'https://api.twitter.com/2';

  async connect(authCode: string): Promise<PlatformConnection> {
    // Exchange code for tokens using PKCE
    const tokens = await this.exchangeCodeForTokens(authCode);
    
    // Get user profile
    const profile = await this.getUserProfile(tokens.accessToken);
    
    // Create connection
    const connection: PlatformConnection = {
      id: '', // Will be generated by Prisma
      userId: '', // Will be set by the calling code
      platform: 'twitter',
      accountId: profile.data.id,
      accountName: profile.data.username,
      accountImage: profile.data.profile_image_url,
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      tokenExpiry: tokens.expiresIn ? new Date(Date.now() + tokens.expiresIn * 1000) : undefined,
      scopes: this.authConfig.scopes,
      isActive: true,
      metadata: {
        twitterId: profile.data.id,
        name: profile.data.name,
        verified: profile.data.verified,
        followersCount: profile.data.public_metrics.followers_count,
        followingCount: profile.data.public_metrics.following_count,
        tweetCount: profile.data.public_metrics.tweet_count,
        listedCount: profile.data.public_metrics.listed_count
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return await this.saveConnection(connection);
  }

  async refreshToken(connection: PlatformConnection): Promise<PlatformConnection> {
    if (!connection.refreshToken) {
      throw new Error('No refresh token available');
    }

    const tokens = await this.refreshAccessToken(connection.refreshToken);
    
    connection.accessToken = tokens.accessToken;
    if (tokens.refreshToken) {
      connection.refreshToken = tokens.refreshToken;
    }
    if (tokens.expiresIn) {
      connection.tokenExpiry = new Date(Date.now() + tokens.expiresIn * 1000);
    }
    
    return await this.saveConnection(connection);
  }

  async publishContent(connectionId: string, content: Partial<PlatformContent>): Promise<PlatformContent> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    // Validate content
    const validation = this.validateContent(content);
    if (!validation.valid) {
      throw new Error(`Invalid content: ${validation.errors?.map(e => e.message).join(', ')}`);
    }

    // Prepare tweet data
    const tweetData: any = {
      text: content.content || content.description || content.title || ''
    };

    // Add media if provided
    if (content.metadata?.mediaIds) {
      tweetData.media = {
        media_ids: content.metadata.mediaIds
      };
    } else if (content.metadata?.mediaFiles) {
      // Upload media first
      const mediaIds = await this.uploadMedia(connection, content.metadata.mediaFiles);
      tweetData.media = {
        media_ids: mediaIds
      };
    }

    // Add reply settings
    if (content.metadata?.replySettings) {
      tweetData.reply_settings = content.metadata.replySettings;
    }

    // Add poll if provided
    if (content.metadata?.poll) {
      tweetData.poll = content.metadata.poll;
    }

    // Add quote tweet or reply
    if (content.metadata?.quoteTweetId) {
      tweetData.quote_tweet_id = content.metadata.quoteTweetId;
    }
    if (content.metadata?.replyToId) {
      tweetData.reply = {
        in_reply_to_tweet_id: content.metadata.replyToId
      };
    }

    // Create tweet
    const response = await fetch(
      `${this.apiBaseUrl}/tweets`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(tweetData)
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Failed to create tweet: ${error.detail || error.title}`);
    }

    const tweet = await response.json();

    // Return created content
    const publishedContent: PlatformContent = {
      id: tweet.data.id,
      platformId: tweet.data.id,
      platform: 'twitter',
      title: this.extractFirstLine(tweet.data.text),
      content: tweet.data.text,
      type: 'text' as ContentType,
      status: 'published',
      publishedAt: new Date(),
      url: `https://twitter.com/${connection.accountName}/status/${tweet.data.id}`,
      hashtags: this.extractHashtags(tweet.data.text),
      mentions: this.extractMentions(tweet.data.text),
      metadata: {
        tweetId: tweet.data.id
      }
    };

    return publishedContent;
  }

  async getAnalytics(connectionId: string, period: { start: Date; end: Date }): Promise<PlatformAnalytics> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    // Get user metrics
    const userMetrics = await this.getUserMetrics(connection);
    
    // Get tweet metrics for the period
    const tweetMetrics = await this.getTweetMetrics(connection, period);
    
    // Get top tweets
    const topTweets = await this.getTopTweets(connection, period);
    
    // Calculate analytics
    return {
      platform: 'twitter',
      connectionId,
      period,
      metrics: {
        followers: userMetrics.followers_count,
        followersGrowth: userMetrics.followers_growth,
        totalViews: tweetMetrics.impression_count,
        totalEngagement: tweetMetrics.like_count + tweetMetrics.retweet_count + tweetMetrics.reply_count,
        avgEngagementRate: tweetMetrics.engagement_rate,
        totalContent: tweetMetrics.tweet_count,
        topContent: topTweets
      },
      audienceData: {
        demographics: {}, // Twitter API v2 doesn't provide demographic data
        topLocations: [],
        activeHours: tweetMetrics.active_hours
      }
    };
  }

  async listContent(connectionId: string, options?: ListOptions): Promise<PlatformContent[]> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    const params = new URLSearchParams({
      'max_results': String(options?.limit || 100),
      'tweet.fields': 'created_at,public_metrics,attachments,entities',
      'media.fields': 'preview_image_url,url',
      'expansions': 'attachments.media_keys'
    });

    if (options?.startDate) {
      params.append('start_time', options.startDate.toISOString());
    }
    if (options?.endDate) {
      params.append('end_time', options.endDate.toISOString());
    }

    const response = await fetch(
      `${this.apiBaseUrl}/users/${connection.metadata?.twitterId}/tweets?${params}`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch tweets');
    }

    const data = await response.json();
    const mediaMap = new Map();
    
    // Map media data
    if (data.includes?.media) {
      data.includes.media.forEach((media: any) => {
        mediaMap.set(media.media_key, media);
      });
    }

    return data.data.map((tweet: any) => {
      let thumbnail;
      if (tweet.attachments?.media_keys) {
        const media = mediaMap.get(tweet.attachments.media_keys[0]);
        thumbnail = media?.preview_image_url || media?.url;
      }

      return {
        id: tweet.id,
        platformId: tweet.id,
        platform: 'twitter',
        title: this.extractFirstLine(tweet.text),
        content: tweet.text,
        type: 'text' as ContentType,
        status: 'published',
        publishedAt: new Date(tweet.created_at),
        url: `https://twitter.com/${connection.accountName}/status/${tweet.id}`,
        thumbnail,
        metrics: tweet.public_metrics ? {
          impressions: tweet.public_metrics.impression_count || 0,
          likes: tweet.public_metrics.like_count || 0,
          retweets: tweet.public_metrics.retweet_count || 0,
          comments: tweet.public_metrics.reply_count || 0,
          clicks: tweet.public_metrics.url_link_clicks || 0
        } : undefined,
        hashtags: this.extractHashtags(tweet.text),
        mentions: this.extractMentions(tweet.text)
      };
    });
  }

  getPlatformLimits(): PlatformLimits {
    return {
      platform: 'twitter',
      content: {
        titleMaxLength: 280, // Tweet character limit
        hashtagsMax: 10, // Practical limit
        mentionsMax: 10, // Practical limit
        mediaMax: 4, // Max images per tweet
        videoMaxDuration: 140, // 2:20 in seconds
        videoMaxSize: 512 * 1024 * 1024, // 512MB
        imageMaxSize: 5 * 1024 * 1024, // 5MB per image
        supportedFormats: ['jpg', 'jpeg', 'png', 'gif', 'mp4', 'mov']
      },
      posting: {
        dailyLimit: 2400, // Twitter's daily tweet limit
        hourlyLimit: 300 // Approximate rate limit
      }
    };
  }

  validateContent(content: Partial<PlatformContent>): ValidationResult {
    const errors: any[] = [];
    const warnings: any[] = [];
    const limits = this.getPlatformLimits();

    // Content validation
    const text = content.content || content.description || content.title || '';
    
    // Calculate effective length with link shortening
    const effectiveLength = this.calculateTweetLength(text);
    
    if (effectiveLength > limits.content.titleMaxLength!) {
      errors.push({ 
        field: 'content', 
        message: `Tweet must be ${limits.content.titleMaxLength} characters or less (currently ${effectiveLength})`, 
        code: 'MAX_LENGTH' 
      });
    }

    // Media validation
    if (content.metadata?.mediaFiles) {
      if (content.metadata.mediaFiles.length > limits.content.mediaMax!) {
        errors.push({
          field: 'media',
          message: `Maximum ${limits.content.mediaMax} media files allowed`,
          code: 'MAX_COUNT'
        });
      }
    }

    // Thread validation
    if (content.metadata?.thread && content.metadata.thread.length > 25) {
      warnings.push({
        field: 'thread',
        message: 'Threads longer than 25 tweets may have reduced reach',
        suggestion: 'Consider breaking into multiple threads'
      });
    }

    // Best practices
    if (!text.includes('@') && !text.includes('#')) {
      warnings.push({
        field: 'content',
        message: 'Tweets with mentions or hashtags tend to get more engagement',
        suggestion: 'Consider adding relevant hashtags or mentioning relevant accounts'
      });
    }

    if (effectiveLength < 50) {
      warnings.push({
        field: 'content',
        message: 'Very short tweets may get less engagement',
        suggestion: 'Consider adding more context or details'
      });
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  protected async testConnection(connection: PlatformConnection): Promise<boolean> {
    try {
      const response = await fetch(
        `${this.apiBaseUrl}/users/me`,
        {
          headers: {
            'Authorization': `Bearer ${connection.accessToken}`
          }
        }
      );

      return response.ok;
    } catch {
      return false;
    }
  }

  // Private helper methods
  private async getUserProfile(accessToken: string): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/users/me?user.fields=id,name,username,profile_image_url,verified,public_metrics`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch user profile');
    }

    return await response.json();
  }

  private async uploadMedia(connection: PlatformConnection, files: any[]): Promise<string[]> {
    const mediaIds: string[] = [];

    for (const file of files) {
      // Twitter media upload is complex and requires v1.1 API
      // This is a simplified placeholder
      const mediaId = await this.uploadSingleMedia(connection, file);
      mediaIds.push(mediaId);
    }

    return mediaIds;
  }

  private async uploadSingleMedia(connection: PlatformConnection, file: any): Promise<string> {
    // Twitter media upload requires multiple steps:
    // 1. INIT - Initialize upload
    // 2. APPEND - Upload chunks
    // 3. FINALIZE - Complete upload
    // This is a placeholder implementation
    return 'media-id-placeholder';
  }

  private async getUserMetrics(connection: PlatformConnection): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/users/${connection.metadata?.twitterId}?user.fields=public_metrics`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch user metrics');
    }

    const data = await response.json();
    
    return {
      followers_count: data.data.public_metrics.followers_count,
      followers_growth: 0, // Would need historical data
      following_count: data.data.public_metrics.following_count,
      tweet_count: data.data.public_metrics.tweet_count
    };
  }

  private async getTweetMetrics(connection: PlatformConnection, period: { start: Date; end: Date }): Promise<any> {
    const tweets = await this.listContent(connection.id, {
      startDate: period.start,
      endDate: period.end,
      limit: 100
    });

    // Aggregate metrics
    const totals = tweets.reduce((acc, tweet) => ({
      impression_count: acc.impression_count + (tweet.metrics?.impressions || 0),
      like_count: acc.like_count + (tweet.metrics?.likes || 0),
      retweet_count: acc.retweet_count + (tweet.metrics?.retweets || 0),
      reply_count: acc.reply_count + (tweet.metrics?.comments || 0),
      url_click_count: acc.url_click_count + (tweet.metrics?.clicks || 0)
    }), {
      impression_count: 0,
      like_count: 0,
      retweet_count: 0,
      reply_count: 0,
      url_click_count: 0
    });

    const engagementRate = totals.impression_count > 0
      ? ((totals.like_count + totals.retweet_count + totals.reply_count) / totals.impression_count) * 100
      : 0;

    // Analyze posting times
    const hourCounts = new Array(24).fill(0);
    tweets.forEach(tweet => {
      const hour = new Date(tweet.publishedAt!).getHours();
      hourCounts[hour]++;
    });

    return {
      ...totals,
      engagement_rate: engagementRate,
      tweet_count: tweets.length,
      active_hours: hourCounts
    };
  }

  private async getTopTweets(connection: PlatformConnection, period: { start: Date; end: Date }): Promise<PlatformContent[]> {
    const tweets = await this.listContent(connection.id, {
      startDate: period.start,
      endDate: period.end,
      limit: 100
    });

    // Sort by engagement
    return tweets
      .sort((a, b) => {
        const engagementA = (a.metrics?.likes || 0) + (a.metrics?.retweets || 0) + (a.metrics?.comments || 0);
        const engagementB = (b.metrics?.likes || 0) + (b.metrics?.retweets || 0) + (b.metrics?.comments || 0);
        return engagementB - engagementA;
      })
      .slice(0, 10);
  }

  private calculateTweetLength(text: string): number {
    // Twitter counts URLs as 23 characters regardless of actual length
    const urlRegex = /https?:\/\/[^\s]+/g;
    let length = text.length;
    
    const urls = text.match(urlRegex);
    if (urls) {
      urls.forEach(url => {
        length = length - url.length + 23;
      });
    }

    return length;
  }

  private extractFirstLine(text: string): string {
    if (!text) return '';
    const lines = text.split('\n');
    return lines[0].substring(0, 50) + (lines[0].length > 50 ? '...' : '');
  }

  private extractHashtags(text: string): string[] {
    const hashtagRegex = /#[\w\u4e00-\u9fa5]+/g;
    return (text.match(hashtagRegex) || []).map(tag => tag.substring(1));
  }

  private extractMentions(text: string): string[] {
    const mentionRegex = /@[\w]+/g;
    return (text.match(mentionRegex) || []).map(mention => mention.substring(1));
  }

  // OAuth 2.0 PKCE implementation
  protected buildAuthUrl(state: string, additionalParams?: Record<string, string>): string {
    const codeChallenge = this.generateCodeChallenge();
    
    const params = new URLSearchParams({
      client_id: this.authConfig.clientId,
      redirect_uri: this.authConfig.redirectUri,
      response_type: 'code',
      scope: this.authConfig.scopes.join(' '),
      state,
      code_challenge: codeChallenge,
      code_challenge_method: 'S256',
      ...additionalParams
    });

    // Store code verifier for later use
    // This would be stored in a session or database
    
    return `${this.authConfig.authUrl}?${params.toString()}`;
  }

  private generateCodeChallenge(): string {
    // Generate code verifier and challenge for PKCE
    // This is a simplified implementation
    const codeVerifier = this.generateRandomString(128);
    // In production, this would use crypto to create SHA256 hash
    return codeVerifier;
  }

  private generateRandomString(length: number): string {
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
    let text = '';
    for (let i = 0; i < length; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }
}