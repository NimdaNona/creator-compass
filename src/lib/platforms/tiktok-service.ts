import { BasePlatformService } from './base-platform-service';
import type {
  PlatformConnection,
  PlatformContent,
  PlatformAnalytics,
  PlatformLimits,
  ValidationResult,
  ContentType,
  ListOptions
} from '@/types/platform-integrations';

export class TikTokService extends BasePlatformService {
  protected platform = 'tiktok' as const;
  protected authConfig = {
    clientId: process.env.TIKTOK_CLIENT_KEY || '',
    clientSecret: process.env.TIKTOK_CLIENT_SECRET || '',
    redirectUri: process.env.TIKTOK_REDIRECT_URI || 'https://creatorsaicompass.com/api/auth/tiktok/callback',
    scopes: [
      'user.info.basic',
      'user.info.profile',
      'user.info.stats',
      'video.list',
      'video.upload',
      'video.publish'
    ],
    authUrl: 'https://www.tiktok.com/v2/auth/authorize',
    tokenUrl: 'https://open.tiktokapis.com/v2/oauth/token'
  };

  private apiBaseUrl = 'https://open.tiktokapis.com/v2';

  async connect(authCode: string): Promise<PlatformConnection> {
    // Exchange code for tokens
    const tokens = await this.exchangeCodeForTokens(authCode);
    
    // Get user profile
    const profile = await this.getUserProfile(tokens.accessToken);
    
    // Create connection
    const connection: PlatformConnection = {
      id: '', // Will be generated by Prisma
      userId: '', // Will be set by the calling code
      platform: 'tiktok',
      accountId: profile.data.user.open_id,
      accountName: profile.data.user.display_name,
      accountImage: profile.data.user.avatar_url,
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      tokenExpiry: tokens.expiresIn ? new Date(Date.now() + tokens.expiresIn * 1000) : undefined,
      scopes: this.authConfig.scopes,
      isActive: true,
      metadata: {
        openId: profile.data.user.open_id,
        unionId: profile.data.user.union_id,
        followerCount: profile.data.user.follower_count,
        followingCount: profile.data.user.following_count,
        likesCount: profile.data.user.likes_count,
        videoCount: profile.data.user.video_count
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return await this.saveConnection(connection);
  }

  async refreshToken(connection: PlatformConnection): Promise<PlatformConnection> {
    if (!connection.refreshToken) {
      throw new Error('No refresh token available');
    }

    const tokens = await this.refreshAccessToken(connection.refreshToken);
    
    connection.accessToken = tokens.accessToken;
    if (tokens.refreshToken) {
      connection.refreshToken = tokens.refreshToken;
    }
    if (tokens.expiresIn) {
      connection.tokenExpiry = new Date(Date.now() + tokens.expiresIn * 1000);
    }
    
    return await this.saveConnection(connection);
  }

  async publishContent(connectionId: string, content: Partial<PlatformContent>): Promise<PlatformContent> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    // Validate content
    const validation = this.validateContent(content);
    if (!validation.valid) {
      throw new Error(`Invalid content: ${validation.errors?.map(e => e.message).join(', ')}`);
    }

    // TikTok requires video content
    if (content.type !== 'video' && content.type !== 'short') {
      throw new Error('TikTok only supports video content');
    }

    // Initialize video upload
    const uploadInfo = await this.initializeUpload(connection, content);
    
    // Upload video chunks
    await this.uploadVideoChunks(connection, uploadInfo, content.metadata?.videoFile);
    
    // Publish video with metadata
    const publishedVideo = await this.publishVideo(connection, uploadInfo, content);

    // Return created content
    const publishedContent: PlatformContent = {
      id: publishedVideo.share_id,
      platformId: publishedVideo.share_id,
      platform: 'tiktok',
      title: content.title || '',
      description: content.description,
      type: 'short' as ContentType,
      status: 'published',
      publishedAt: new Date(publishedVideo.create_time * 1000),
      url: `https://www.tiktok.com/@${connection.accountName}/video/${publishedVideo.share_id}`,
      thumbnail: publishedVideo.cover_image_url,
      hashtags: content.hashtags,
      mentions: content.mentions,
      metadata: {
        shareId: publishedVideo.share_id,
        duration: publishedVideo.duration
      }
    };

    return publishedContent;
  }

  async getAnalytics(connectionId: string, period: { start: Date; end: Date }): Promise<PlatformAnalytics> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    // Get user stats
    const userStats = await this.getUserStats(connection);
    
    // Get video analytics
    const videoAnalytics = await this.getVideoAnalytics(connection, period);
    
    // Get top videos
    const topVideos = await this.getTopVideos(connection, videoAnalytics);

    return {
      platform: 'tiktok',
      connectionId,
      period,
      metrics: {
        followers: userStats.follower_count,
        followersGrowth: userStats.follower_count_growth,
        totalViews: videoAnalytics.total_views,
        totalEngagement: videoAnalytics.total_likes + videoAnalytics.total_comments + videoAnalytics.total_shares,
        avgEngagementRate: videoAnalytics.avg_engagement_rate,
        totalContent: userStats.video_count,
        topContent: topVideos
      },
      audienceData: {
        demographics: userStats.demographics,
        topLocations: userStats.top_countries,
        activeHours: userStats.active_hours
      }
    };
  }

  async listContent(connectionId: string, options?: ListOptions): Promise<PlatformContent[]> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    const params = new URLSearchParams({
      max_count: String(options?.limit || 20),
      sort_by: options?.sortBy === 'date' ? 'create_time' : 'view_count'
    });

    const response = await fetch(
      `${this.apiBaseUrl}/video/list?${params}`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`,
          'Content-Type': 'application/json'
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch videos');
    }

    const data = await response.json();

    return data.data.videos.map((video: any) => ({
      id: video.share_id,
      platformId: video.share_id,
      platform: 'tiktok',
      title: video.title || '',
      description: video.description,
      type: 'short' as ContentType,
      status: 'published',
      publishedAt: new Date(video.create_time * 1000),
      url: `https://www.tiktok.com/@${connection.accountName}/video/${video.share_id}`,
      thumbnail: video.cover_image_url,
      metrics: {
        views: video.view_count,
        likes: video.like_count,
        comments: video.comment_count,
        shares: video.share_count,
        saves: video.download_count
      },
      hashtags: this.extractHashtags(video.description),
      mentions: this.extractMentions(video.description),
      metadata: {
        duration: video.duration,
        musicId: video.music_id,
        effectIds: video.effect_ids
      }
    }));
  }

  getPlatformLimits(): PlatformLimits {
    return {
      platform: 'tiktok',
      content: {
        titleMaxLength: 150,
        descriptionMaxLength: 2200,
        hashtagsMax: 100, // TikTok allows many hashtags but recommends 3-5
        mentionsMax: 30,
        videoMaxDuration: 10 * 60, // 10 minutes in seconds
        videoMaxSize: 287 * 1024 * 1024, // 287MB for mobile, 1GB for web
        supportedFormats: ['mp4', 'mov', 'mpeg', '3gp', 'avi']
      },
      posting: {
        // TikTok doesn't have strict API posting limits but recommends spacing out posts
        dailyLimit: 100,
        hourlyLimit: 10
      }
    };
  }

  validateContent(content: Partial<PlatformContent>): ValidationResult {
    const errors: any[] = [];
    const warnings: any[] = [];
    const limits = this.getPlatformLimits();

    // Content type validation
    if (content.type && content.type !== 'video' && content.type !== 'short') {
      errors.push({ 
        field: 'type', 
        message: 'TikTok only supports video content', 
        code: 'INVALID_TYPE' 
      });
    }

    // Description validation (TikTok combines title and description)
    const fullText = `${content.title || ''} ${content.description || ''}`.trim();
    if (fullText.length > limits.content.descriptionMaxLength!) {
      errors.push({ 
        field: 'description', 
        message: `Text must be ${limits.content.descriptionMaxLength} characters or less`, 
        code: 'MAX_LENGTH' 
      });
    }

    // Video file validation
    if (!content.metadata?.videoFile) {
      errors.push({ field: 'video', message: 'Video file is required', code: 'REQUIRED_FIELD' });
    }

    // Hashtag validation
    const hashtags = content.hashtags || [];
    if (hashtags.length > 100) {
      errors.push({
        field: 'hashtags',
        message: 'Maximum 100 hashtags allowed',
        code: 'MAX_COUNT'
      });
    } else if (hashtags.length > 5) {
      warnings.push({
        field: 'hashtags',
        message: 'TikTok recommends using 3-5 hashtags for optimal reach',
        suggestion: 'Consider reducing to your most relevant hashtags'
      });
    }

    // Best practices
    if (!content.metadata?.musicId && !content.metadata?.originalSound) {
      warnings.push({
        field: 'audio',
        message: 'Videos with trending sounds tend to get more views',
        suggestion: 'Consider adding a trending sound or music'
      });
    }

    if (fullText.length < 50) {
      warnings.push({
        field: 'description',
        message: 'Add a more detailed caption for better engagement',
        suggestion: 'Tell a story or ask a question to encourage comments'
      });
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  protected async testConnection(connection: PlatformConnection): Promise<boolean> {
    try {
      const response = await fetch(
        `${this.apiBaseUrl}/user/info`,
        {
          headers: {
            'Authorization': `Bearer ${connection.accessToken}`
          }
        }
      );

      return response.ok;
    } catch {
      return false;
    }
  }

  // Private helper methods
  private async getUserProfile(accessToken: string): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/user/info?fields=open_id,union_id,display_name,avatar_url,follower_count,following_count,likes_count,video_count`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch user profile');
    }

    return await response.json();
  }

  private async initializeUpload(connection: PlatformConnection, content: Partial<PlatformContent>): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/share/video/upload`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          post_info: {
            title: content.title,
            privacy_level: content.metadata?.privacy || 'PUBLIC_TO_EVERYONE',
            disable_comment: false,
            disable_duet: false,
            disable_stitch: false,
            video_cover_timestamp_ms: 1000
          },
          source_info: {
            source: 'FILE_UPLOAD',
            video_size: content.metadata?.videoFile?.size || 0,
            chunk_size: 10 * 1024 * 1024, // 10MB chunks
            total_chunk_count: Math.ceil((content.metadata?.videoFile?.size || 0) / (10 * 1024 * 1024))
          }
        })
      }
    );

    if (!response.ok) {
      throw new Error('Failed to initialize upload');
    }

    return await response.json();
  }

  private async uploadVideoChunks(connection: PlatformConnection, uploadInfo: any, videoFile: any): Promise<void> {
    // This would implement chunked upload to TikTok
    // For now, placeholder implementation
    console.log('Uploading video chunks to TikTok...');
  }

  private async publishVideo(connection: PlatformConnection, uploadInfo: any, content: Partial<PlatformContent>): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/share/video/upload/complete`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          upload_id: uploadInfo.upload_id,
          post_info: {
            title: content.title,
            description: content.description,
            privacy_level: content.metadata?.privacy || 'PUBLIC_TO_EVERYONE',
            disable_comment: false,
            disable_duet: false,
            disable_stitch: false
          }
        })
      }
    );

    if (!response.ok) {
      throw new Error('Failed to publish video');
    }

    return await response.json();
  }

  private async getUserStats(connection: PlatformConnection): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/user/stats?fields=follower_count,following_count,likes_count,video_count`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch user stats');
    }

    const data = await response.json();
    
    // Calculate growth (would need historical data)
    return {
      ...data.data,
      follower_count_growth: 0, // Placeholder
      demographics: {}, // Would need additional API calls
      top_countries: [], // Would need additional API calls
      active_hours: [] // Would need additional API calls
    };
  }

  private async getVideoAnalytics(connection: PlatformConnection, period: { start: Date; end: Date }): Promise<any> {
    // TikTok's analytics API is limited, so we'll aggregate from individual videos
    const videos = await this.listContent(connection.id, { limit: 100 });
    
    const videosInPeriod = videos.filter(v => {
      const publishDate = new Date(v.publishedAt!);
      return publishDate >= period.start && publishDate <= period.end;
    });

    const totals = videosInPeriod.reduce((acc, video) => ({
      total_views: acc.total_views + (video.metrics?.views || 0),
      total_likes: acc.total_likes + (video.metrics?.likes || 0),
      total_comments: acc.total_comments + (video.metrics?.comments || 0),
      total_shares: acc.total_shares + (video.metrics?.shares || 0)
    }), { total_views: 0, total_likes: 0, total_comments: 0, total_shares: 0 });

    const avgEngagementRate = totals.total_views > 0
      ? ((totals.total_likes + totals.total_comments + totals.total_shares) / totals.total_views) * 100
      : 0;

    return {
      ...totals,
      avg_engagement_rate: avgEngagementRate
    };
  }

  private async getTopVideos(connection: PlatformConnection, analytics: any): Promise<PlatformContent[]> {
    const videos = await this.listContent(connection.id, {
      limit: 10,
      sortBy: 'views'
    });

    return videos;
  }

  private extractHashtags(text: string): string[] {
    const hashtagRegex = /#[\w\u4e00-\u9fa5]+/g;
    return (text.match(hashtagRegex) || []).map(tag => tag.substring(1));
  }

  private extractMentions(text: string): string[] {
    const mentionRegex = /@[\w\u4e00-\u9fa5]+/g;
    return (text.match(mentionRegex) || []).map(mention => mention.substring(1));
  }
}