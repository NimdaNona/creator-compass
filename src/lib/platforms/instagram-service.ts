import { BasePlatformService } from './base-platform-service';
import type {
  PlatformConnection,
  PlatformContent,
  PlatformAnalytics,
  PlatformLimits,
  ValidationResult,
  ContentType,
  ListOptions
} from '@/types/platform-integrations';

export class InstagramService extends BasePlatformService {
  protected platform = 'instagram' as const;
  protected authConfig = {
    clientId: process.env.INSTAGRAM_APP_ID || '',
    clientSecret: process.env.INSTAGRAM_APP_SECRET || '',
    redirectUri: process.env.INSTAGRAM_REDIRECT_URI || 'https://creatorsaicompass.com/api/auth/instagram/callback',
    scopes: [
      'instagram_basic',
      'instagram_content_publish',
      'instagram_manage_comments',
      'instagram_manage_insights',
      'pages_show_list',
      'pages_read_engagement'
    ],
    authUrl: 'https://www.facebook.com/v18.0/dialog/oauth',
    tokenUrl: 'https://graph.facebook.com/v18.0/oauth/access_token'
  };

  private apiBaseUrl = 'https://graph.facebook.com/v18.0';

  async connect(authCode: string): Promise<PlatformConnection> {
    // Exchange code for tokens
    const tokens = await this.exchangeCodeForTokens(authCode);
    
    // Get Facebook pages (Instagram Business accounts are linked to FB pages)
    const pages = await this.getFacebookPages(tokens.accessToken);
    
    // Get Instagram Business Account ID
    const instagramAccount = await this.getInstagramBusinessAccount(pages[0].id, pages[0].access_token);
    
    // Get Instagram profile
    const profile = await this.getInstagramProfile(instagramAccount.id, pages[0].access_token);
    
    // Create connection
    const connection: PlatformConnection = {
      id: '', // Will be generated by Prisma
      userId: '', // Will be set by the calling code
      platform: 'instagram',
      accountId: instagramAccount.id,
      accountName: profile.username,
      accountImage: profile.profile_picture_url,
      accessToken: pages[0].access_token, // Use page access token
      refreshToken: tokens.refreshToken,
      tokenExpiry: tokens.expiresIn ? new Date(Date.now() + tokens.expiresIn * 1000) : undefined,
      scopes: this.authConfig.scopes,
      isActive: true,
      metadata: {
        instagramBusinessAccountId: instagramAccount.id,
        facebookPageId: pages[0].id,
        followersCount: profile.followers_count,
        followsCount: profile.follows_count,
        mediaCount: profile.media_count,
        biography: profile.biography,
        website: profile.website
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return await this.saveConnection(connection);
  }

  async refreshToken(connection: PlatformConnection): Promise<PlatformConnection> {
    // Instagram uses Facebook's token refresh mechanism
    const response = await fetch(
      `${this.apiBaseUrl}/oauth/access_token?` +
      `grant_type=fb_exchange_token&` +
      `client_id=${this.authConfig.clientId}&` +
      `client_secret=${this.authConfig.clientSecret}&` +
      `fb_exchange_token=${connection.accessToken}`
    );

    if (!response.ok) {
      throw new Error('Failed to refresh token');
    }

    const data = await response.json();
    
    connection.accessToken = data.access_token;
    if (data.expires_in) {
      connection.tokenExpiry = new Date(Date.now() + data.expires_in * 1000);
    }
    
    return await this.saveConnection(connection);
  }

  async publishContent(connectionId: string, content: Partial<PlatformContent>): Promise<PlatformContent> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    // Validate content
    const validation = this.validateContent(content);
    if (!validation.valid) {
      throw new Error(`Invalid content: ${validation.errors?.map(e => e.message).join(', ')}`);
    }

    let mediaId: string;

    switch (content.type) {
      case 'image':
        mediaId = await this.createImagePost(connection, content);
        break;
      case 'carousel':
        mediaId = await this.createCarouselPost(connection, content);
        break;
      case 'reel':
      case 'video':
        mediaId = await this.createReelPost(connection, content);
        break;
      default:
        throw new Error('Unsupported content type for Instagram');
    }

    // Publish the media
    const publishedMedia = await this.publishMedia(connection, mediaId);

    // Get media details
    const mediaDetails = await this.getMediaDetails(connection, publishedMedia.id);

    // Return created content
    const publishedContent: PlatformContent = {
      id: publishedMedia.id,
      platformId: publishedMedia.id,
      platform: 'instagram',
      title: content.title || '',
      description: content.description || content.title || '',
      type: content.type as ContentType,
      status: 'published',
      publishedAt: new Date(),
      url: mediaDetails.permalink,
      thumbnail: mediaDetails.thumbnail_url || mediaDetails.media_url,
      hashtags: content.hashtags,
      mentions: content.mentions,
      location: content.location,
      metadata: {
        mediaType: mediaDetails.media_type,
        mediaId: publishedMedia.id
      }
    };

    return publishedContent;
  }

  async getAnalytics(connectionId: string, period: { start: Date; end: Date }): Promise<PlatformAnalytics> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    // Get account insights
    const accountInsights = await this.getAccountInsights(connection, period);
    
    // Get media insights
    const mediaInsights = await this.getMediaInsights(connection, period);
    
    // Get top posts
    const topPosts = await this.getTopPosts(connection, mediaInsights);
    
    // Get audience insights
    const audienceInsights = await this.getAudienceInsights(connection);

    return {
      platform: 'instagram',
      connectionId,
      period,
      metrics: {
        followers: accountInsights.followers_count,
        followersGrowth: accountInsights.follower_count_growth,
        totalViews: mediaInsights.impressions,
        totalEngagement: mediaInsights.engagement,
        avgEngagementRate: mediaInsights.engagement_rate,
        totalContent: accountInsights.media_count,
        topContent: topPosts
      },
      audienceData: audienceInsights
    };
  }

  async listContent(connectionId: string, options?: ListOptions): Promise<PlatformContent[]> {
    const connection = await this.getConnection(connectionId);
    if (!connection) throw new Error('Connection not found');

    const params = new URLSearchParams({
      fields: 'id,caption,media_type,media_url,thumbnail_url,permalink,timestamp,like_count,comments_count,insights.metric(impressions,reach,engagement)',
      limit: String(options?.limit || 25)
    });

    const response = await fetch(
      `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}/media?${params}`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch media');
    }

    const data = await response.json();

    return data.data.map((media: any) => ({
      id: media.id,
      platformId: media.id,
      platform: 'instagram',
      title: this.extractFirstLine(media.caption),
      description: media.caption,
      type: this.mapMediaType(media.media_type),
      status: 'published',
      publishedAt: new Date(media.timestamp),
      url: media.permalink,
      thumbnail: media.thumbnail_url || media.media_url,
      metrics: {
        likes: media.like_count || 0,
        comments: media.comments_count || 0,
        impressions: media.insights?.data?.find((i: any) => i.name === 'impressions')?.values?.[0]?.value || 0,
        reach: media.insights?.data?.find((i: any) => i.name === 'reach')?.values?.[0]?.value || 0,
        engagement: media.insights?.data?.find((i: any) => i.name === 'engagement')?.values?.[0]?.value || 0
      },
      hashtags: this.extractHashtags(media.caption || ''),
      mentions: this.extractMentions(media.caption || ''),
      metadata: {
        mediaType: media.media_type
      }
    }));
  }

  getPlatformLimits(): PlatformLimits {
    return {
      platform: 'instagram',
      content: {
        descriptionMaxLength: 2200,
        hashtagsMax: 30,
        mentionsMax: 20,
        mediaMax: 10, // For carousel posts
        videoMaxDuration: 90, // 90 seconds for Reels
        videoMaxSize: 4 * 1024 * 1024 * 1024, // 4GB
        imageMaxSize: 8 * 1024 * 1024, // 8MB
        supportedFormats: ['jpg', 'jpeg', 'png', 'mp4', 'mov']
      },
      posting: {
        dailyLimit: 25, // Instagram's recommended limit
        hourlyLimit: 5
      }
    };
  }

  validateContent(content: Partial<PlatformContent>): ValidationResult {
    const errors: any[] = [];
    const warnings: any[] = [];
    const limits = this.getPlatformLimits();

    // Content type validation
    const supportedTypes = ['image', 'carousel', 'reel', 'video', 'story'];
    if (content.type && !supportedTypes.includes(content.type)) {
      errors.push({ 
        field: 'type', 
        message: `Instagram supports: ${supportedTypes.join(', ')}`, 
        code: 'INVALID_TYPE' 
      });
    }

    // Caption validation (Instagram uses description as caption)
    const caption = content.description || content.title || '';
    if (caption.length > limits.content.descriptionMaxLength!) {
      errors.push({ 
        field: 'description', 
        message: `Caption must be ${limits.content.descriptionMaxLength} characters or less`, 
        code: 'MAX_LENGTH' 
      });
    }

    // Media validation
    if (!content.metadata?.mediaUrl && !content.metadata?.mediaFiles) {
      errors.push({ field: 'media', message: 'Media file is required', code: 'REQUIRED_FIELD' });
    }

    // Hashtag validation
    const hashtags = content.hashtags || [];
    if (hashtags.length > limits.content.hashtagsMax!) {
      errors.push({
        field: 'hashtags',
        message: `Maximum ${limits.content.hashtagsMax} hashtags allowed`,
        code: 'MAX_COUNT'
      });
    }

    // Mention validation
    const mentions = content.mentions || [];
    if (mentions.length > limits.content.mentionsMax!) {
      errors.push({
        field: 'mentions',
        message: `Maximum ${limits.content.mentionsMax} mentions allowed`,
        code: 'MAX_COUNT'
      });
    }

    // Best practices
    if (hashtags.length === 0) {
      warnings.push({
        field: 'hashtags',
        message: 'Posts with hashtags get more engagement',
        suggestion: 'Add 5-10 relevant hashtags'
      });
    }

    if (caption.length < 50 && content.type !== 'story') {
      warnings.push({
        field: 'description',
        message: 'Longer captions tend to get more engagement',
        suggestion: 'Tell a story or ask a question to encourage comments'
      });
    }

    if (content.type === 'carousel' && (!content.metadata?.mediaFiles || content.metadata.mediaFiles.length < 2)) {
      errors.push({
        field: 'media',
        message: 'Carousel posts require at least 2 images',
        code: 'MIN_COUNT'
      });
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  protected async testConnection(connection: PlatformConnection): Promise<boolean> {
    try {
      const response = await fetch(
        `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}?fields=id`,
        {
          headers: {
            'Authorization': `Bearer ${connection.accessToken}`
          }
        }
      );

      return response.ok;
    } catch {
      return false;
    }
  }

  // Private helper methods
  private async getFacebookPages(accessToken: string): Promise<any[]> {
    const response = await fetch(
      `${this.apiBaseUrl}/me/accounts?fields=id,name,access_token`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch Facebook pages');
    }

    const data = await response.json();
    return data.data;
  }

  private async getInstagramBusinessAccount(pageId: string, pageAccessToken: string): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/${pageId}?fields=instagram_business_account`,
      {
        headers: {
          'Authorization': `Bearer ${pageAccessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch Instagram business account');
    }

    const data = await response.json();
    if (!data.instagram_business_account) {
      throw new Error('No Instagram business account linked to this Facebook page');
    }

    return data.instagram_business_account;
  }

  private async getInstagramProfile(instagramAccountId: string, accessToken: string): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/${instagramAccountId}?fields=username,profile_picture_url,followers_count,follows_count,media_count,biography,website`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch Instagram profile');
    }

    return await response.json();
  }

  private async createImagePost(connection: PlatformConnection, content: Partial<PlatformContent>): Promise<string> {
    const response = await fetch(
      `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}/media`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          image_url: content.metadata?.mediaUrl,
          caption: content.description || content.title,
          location_id: content.metadata?.locationId,
          user_tags: content.metadata?.userTags
        })
      }
    );

    if (!response.ok) {
      throw new Error('Failed to create image post');
    }

    const data = await response.json();
    return data.id;
  }

  private async createCarouselPost(connection: PlatformConnection, content: Partial<PlatformContent>): Promise<string> {
    // First, create carousel items
    const carouselItems = await Promise.all(
      content.metadata?.mediaFiles.map(async (file: any) => {
        const itemResponse = await fetch(
          `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}/media`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${connection.accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              image_url: file.url,
              is_carousel_item: true
            })
          }
        );

        const itemData = await itemResponse.json();
        return itemData.id;
      })
    );

    // Then create the carousel container
    const response = await fetch(
      `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}/media`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          media_type: 'CAROUSEL',
          children: carouselItems,
          caption: content.description || content.title,
          location_id: content.metadata?.locationId,
          user_tags: content.metadata?.userTags
        })
      }
    );

    if (!response.ok) {
      throw new Error('Failed to create carousel post');
    }

    const data = await response.json();
    return data.id;
  }

  private async createReelPost(connection: PlatformConnection, content: Partial<PlatformContent>): Promise<string> {
    const response = await fetch(
      `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}/media`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          media_type: 'REELS',
          video_url: content.metadata?.mediaUrl,
          caption: content.description || content.title,
          share_to_feed: content.metadata?.shareToFeed !== false,
          location_id: content.metadata?.locationId,
          thumb_offset: content.metadata?.thumbOffset || 0,
          audio_name: content.metadata?.audioName
        })
      }
    );

    if (!response.ok) {
      throw new Error('Failed to create reel post');
    }

    const data = await response.json();
    return data.id;
  }

  private async publishMedia(connection: PlatformConnection, creationId: string): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}/media_publish`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          creation_id: creationId
        })
      }
    );

    if (!response.ok) {
      throw new Error('Failed to publish media');
    }

    return await response.json();
  }

  private async getMediaDetails(connection: PlatformConnection, mediaId: string): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/${mediaId}?fields=id,media_type,media_url,thumbnail_url,permalink,timestamp`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to get media details');
    }

    return await response.json();
  }

  private async getAccountInsights(connection: PlatformConnection, period: { start: Date; end: Date }): Promise<any> {
    const metrics = [
      'impressions',
      'reach',
      'profile_views',
      'website_clicks',
      'email_contacts',
      'phone_call_clicks',
      'text_message_clicks',
      'get_directions_clicks'
    ];

    const response = await fetch(
      `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}/insights?` +
      `metric=${metrics.join(',')}&` +
      `period=day&` +
      `since=${Math.floor(period.start.getTime() / 1000)}&` +
      `until=${Math.floor(period.end.getTime() / 1000)}`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch account insights');
    }

    const data = await response.json();
    
    // Process insights data
    const insights: any = {};
    data.data.forEach((metric: any) => {
      const total = metric.values.reduce((sum: number, day: any) => sum + day.value, 0);
      insights[metric.name] = total;
    });

    // Get current follower count
    const profileResponse = await fetch(
      `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}?fields=followers_count,media_count`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    const profileData = await profileResponse.json();

    return {
      ...insights,
      followers_count: profileData.followers_count,
      media_count: profileData.media_count,
      follower_count_growth: 0 // Would need historical data
    };
  }

  private async getMediaInsights(connection: PlatformConnection, period: { start: Date; end: Date }): Promise<any> {
    const media = await this.listContent(connection.id, { limit: 100 });
    
    const mediaInPeriod = media.filter(m => {
      const publishDate = new Date(m.publishedAt!);
      return publishDate >= period.start && publishDate <= period.end;
    });

    const totals = mediaInPeriod.reduce((acc, post) => ({
      impressions: acc.impressions + (post.metrics?.impressions || 0),
      reach: acc.reach + (post.metrics?.reach || 0),
      engagement: acc.engagement + (post.metrics?.likes || 0) + (post.metrics?.comments || 0),
      likes: acc.likes + (post.metrics?.likes || 0),
      comments: acc.comments + (post.metrics?.comments || 0)
    }), { impressions: 0, reach: 0, engagement: 0, likes: 0, comments: 0 });

    const engagementRate = totals.impressions > 0
      ? (totals.engagement / totals.impressions) * 100
      : 0;

    return {
      ...totals,
      engagement_rate: engagementRate
    };
  }

  private async getTopPosts(connection: PlatformConnection, insights: any): Promise<PlatformContent[]> {
    const posts = await this.listContent(connection.id, { limit: 10 });
    
    // Sort by engagement
    return posts.sort((a, b) => {
      const engagementA = (a.metrics?.likes || 0) + (a.metrics?.comments || 0);
      const engagementB = (b.metrics?.likes || 0) + (b.metrics?.comments || 0);
      return engagementB - engagementA;
    });
  }

  private async getAudienceInsights(connection: PlatformConnection): Promise<any> {
    const response = await fetch(
      `${this.apiBaseUrl}/${connection.metadata?.instagramBusinessAccountId}/insights?` +
      `metric=audience_gender_age,audience_locale,audience_country,audience_city&` +
      `period=lifetime`,
      {
        headers: {
          'Authorization': `Bearer ${connection.accessToken}`
        }
      }
    );

    if (!response.ok) {
      return null;
    }

    const data = await response.json();
    
    const demographics: any = {
      age: {},
      gender: {},
      location: {}
    };

    data.data.forEach((metric: any) => {
      if (metric.name === 'audience_gender_age') {
        // Process gender and age data
        Object.entries(metric.values[0].value).forEach(([key, value]) => {
          const [gender, ageRange] = key.split('.');
          demographics.age[ageRange] = (demographics.age[ageRange] || 0) + (value as number);
          demographics.gender[gender] = (demographics.gender[gender] || 0) + (value as number);
        });
      } else if (metric.name === 'audience_country') {
        demographics.location = metric.values[0].value;
      }
    });

    return {
      demographics,
      topLocations: Object.keys(demographics.location || {}).slice(0, 5),
      activeHours: [] // Instagram doesn't provide this via API
    };
  }

  private extractFirstLine(text: string): string {
    if (!text) return '';
    const lines = text.split('\n');
    return lines[0].substring(0, 50) + (lines[0].length > 50 ? '...' : '');
  }

  private mapMediaType(instagramType: string): ContentType {
    switch (instagramType) {
      case 'IMAGE':
        return 'image';
      case 'VIDEO':
        return 'video';
      case 'CAROUSEL_ALBUM':
        return 'carousel';
      case 'REELS':
        return 'reel';
      default:
        return 'image';
    }
  }

  private extractHashtags(text: string): string[] {
    const hashtagRegex = /#[\w\u4e00-\u9fa5]+/g;
    return (text.match(hashtagRegex) || []).map(tag => tag.substring(1));
  }

  private extractMentions(text: string): string[] {
    const mentionRegex = /@[\w\u4e00-\u9fa5]+/g;
    return (text.match(mentionRegex) || []).map(mention => mention.substring(1));
  }
}